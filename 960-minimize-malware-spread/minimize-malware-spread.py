class DSU:
    def __init__(self,n):
        self.parent=list(range(n))
        self.size=[1]*n

    def find(self,x):
        if self.parent[x]!=x:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]
    def union(self,x,y):
        rx,ry=self.find(x),self.find(y)
        if rx==ry: return 
        if self.size[rx]<self.size[ry]:
            rx,ry=ry,rx
        self.parent[ry]=rx
        self.size[rx]+=self.size[ry]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        given adjacency matrix of its undirected graph
        Union-find and get the graphs and find the more nodes one and remove it from list OR we can use DFS on each one
        and make it colored and get it answer O(n2)
        """
        #1. do the grouping of graphs
        n=len(graph)
        dsu=DSU(n)
        for i in range(n):
            for j in range(i+1,n):
                if graph[i][j]:
                    dsu.union(i,j)
        #2.count the infested node in this group
        infest_cnt=[0]*n
        for node in initial:
            infest_cnt[dsu.find(node)]+=1 #include it
        #3.greedy find the best one 
        initial.sort()
        best_node,best_save=initial[0],0

        for node in initial:
            root=dsu.find(node)
            save=0
            if infest_cnt[root]==1:
                #in that group it only infested so removing this can be better but we need size of it
                save=dsu.size[root]
            else:
                save=0 # so there are other infested in that groups
            
            if save>best_save or(save==best_save and node<best_node):#we want mini val
                best_save=save
                best_node=node
        return best_node
        
